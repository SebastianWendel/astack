#!/bin/bash
#-----------------------------------------------------------------------------------------------------
# Name:         astack for atlassian
# Description:  show, install, update, backup and restore atlassian products
# Plattform:    Debian, Ubuntu
# Created:      01.09.2012
# Version:      0.1.2
# Author:       Sebastian Wendel, SourceIndex IT-Services, Hamburg/Germany
# License:      Apache License, Version 2.0
#-----------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------
# DevOpts:
#-----------------------------------------------------------------------------------------------------
# alias purge="sudo ./astack purge --debug && sudo aptitude purge -y postfix mysql-server git xmlstarlet && sudo rm -rf /var/lib/mysql/ /var/log/astack.log"
# alias inst="sudo ./astack install --domain example.com --alt-names --debug"

#-----------------------------------------------------------------------------------------------------
# script behavior
#-----------------------------------------------------------------------------------------------------
#set -o nounset
#set -o errexit

#-----------------------------------------------------------------------------------------------------
# configuration
#-----------------------------------------------------------------------------------------------------
APPS='crowd confluence jira stash fisheye'
PATH_DEST='/opt'
PATH_TEMP='/tmp'
LOG_FILE='/var/log/astack.log'
LOG_LEVEL='INFO'
MAX_BINS=3
MAX_BACKUPS=7

#-----------------------------------------------------------------------------------------------------
# script usage
#-----------------------------------------------------------------------------------------------------
USAGE="\nUSAGE: $(basename $0) [SUBCOMMAND] [OPTIONS] ...

Subcommands:
show           show the latest available version to install 
install        installs the specified applications
update         update the specified applications to the latest release
backup         backup the current applications
restore        restore the specified applications from the latest backup
purge          remove all installations including there data, but no system componets

Options:
--domain       specifie the your domain, there is no default
--application  specifie the applications, the default is: ${APPS}
--destination  specifie the destination folder, the default is: ${PATH_DEST}
--alt-names    specifie altenative secondary domain names 
--ext-proxy    use that switch to export the proxy config for another system
--debug        run the script with debugging output
--verbose      run the script with developer output
-h -? --help   show that help output

Some Examples:
$(basename $0) show
$(basename $0) install --domain example.com
$(basename $0) install --domain example.com --alt-names --application \"confluence jira\"
$(basename $0) update --domain example.com --alt-names --ext-proxy
$(basename $0) backup
$(basename $0) restore

Exit status:
 0  if OK
 1  if minor problems\n"

ERROR="\nERROR: You need to pass a subcommand like install or update and a option like --domain\n"

#-----------------------------------------------------------------------------------------------------
# variable
#-----------------------------------------------------------------------------------------------------
TIMESTAMP=$(date +%Y%m%d%H%M%S)
DOMAIN=0
JOB_SHOW=0
JOB_INSTALL=0
JOB_UPDATE=0
JOB_BACKUP=0
JOB_RESTORE=0
JOB_PURGE=0
JOB_TEST=0
VERSION_NOW=0
VERSION_UPDATE=0
ALT_NAMES=0
EXT_PROXY=0
PKG_DEBIAN="bc git xmlstarlet"
PKG_REDHAT=""

#-----------------------------------------------------------------------------------------------------
# control structure
#-----------------------------------------------------------------------------------------------------
if [ "x${1}" == "x" ]; then
  echo -e "${USAGE}"
  exit 1
fi

if [ $# -gt 0 ] ; then
  while true ; do
    case $1 in
      show)          JOB_SHOW=1 ;;
      install)       JOB_INSTALL=1 ;;
      update)        JOB_UPDATE=1 ;;
      backup)        JOB_BACKUP=1 ;;
      restore)       JOB_RESTORE=1 ;;
      purge)         JOB_PURGE=1 ;;
      test)          JOB_TEST=1 ;;
      --domain)      shift; DOMAIN=$1 ;;
      --application) shift; APPS=$1 ;;
      --destination) shift; PATH_DEST=$1 ;;
      --alt-names)   ALT_NAMES=1 ;;
      --ext-proxy)   EXT_PROXY=1 ;;
      --debug)       LOG_LEVEL='DEBUG' ;;
      --verbose)     shift; set -x ;;
      -h|-?|--help)  echo -e "${USAGE}"; exit ;;
      *)             echo -e "${ERROR}"; exit 1 ;;
    esac
    shift
    [ $# -eq 0 ] && break
  done
fi

if [ "${JOB_INSTALL}" -eq 0 ] || [ "${JOB_UPDATE}" -eq 0 ] || [ "${JOB_PURGE}" -eq 0 ] || [ "${JOB_BACKUP}" -eq 0 ] || [ ${JOB_TEST} -eq 0 ] || [ ${JOB_SHOW} -eq 0 ]; then
  if [ "${JOB_INSTALL}" -ne 0 ] || [ "${JOB_UPDATE}" -ne 0 ]; then
    if [ "${DOMAIN}" == "0" ] || [ "x${DOMAIN}" == "x" ]; then
      echo -e "${ERROR}"
      exit 1
    fi
  fi
fi

#-----------------------------------------------------------------------------------------------------
# environment
#-----------------------------------------------------------------------------------------------------

# GET WORKING DIRECTORY
SCRIPT="${0}"
while [ -h "${SCRIPT}" ] ; do
  ls=$(ls -ld "${SCRIPT}")
  link=$(expr "${ls}" : '.*-> \(.*\)$')
  if expr "${link}" : '/.*' > /dev/null; then
    SCRIPT="${link}"
  else
    SCRIPT=$(dirname "${SCRIPT}")/"${link}"
  fi
done
MD_HOME=$(dirname "${SCRIPT}")/..
export MD_HOME=$(cd ${MD_HOME}; pwd)

# GET DISTRIBUTION TYPE
if [ -f /etc/lsb-release ]; then
  . /etc/lsb-release
  DISTRO=${DISTRIB_ID}
elif [ -f /etc/debian_version ]; then
  DISTRO="debian"
elif [ -f /etc/redhat-release ]; then
  DISTRO="redhat"
else
  DISTRO=$(uname -s)
  exit 1
fi

# GET KERNEL ARCHITECTURE
case $(uname -m) in
  x86_64)
    ARCH=64
    ;;
  i*86)
    ARCH=32
    ;;
  *)
    ARCH=?
    ;;
esac

# CHECK IF SCRIPT IS RUNNING BY ROOT
if [ "$(id -u)" != "0" ]; then
  echo "This script must be run as root, script will exit!" 1>&2
  exit 1
fi

# CHECK IF SCRIPT IS ALREADY RUNNING
if [ $(pgrep $(basename $0) | wc -l) -gt 2 ]; then
  echo "This script is already running, script will exit now."
  exit
fi

#-----------------------------------------------------------------------------------------------------
# functions
#-----------------------------------------------------------------------------------------------------
function logger() {
  TIME_STAMP=$(date +'%Y-%m-%d %T')
  if [ ${1} == "INFO" ] || [ ${1} == "ERROR" ]; then
    if [ ${1} == "INFO" ]; then
      echo -e "${TIME_STAMP} [${1}]  ${2}" >> ${LOG_FILE} && echo -e "${2}"
    else
      echo -e "${TIME_STAMP} [${1}] ${2}" >> ${LOG_FILE} && echo -e "${2}"
    fi
  elif [ ${LOG_LEVEL} == "DEBUG" ]; then
    if [ ${1} == "WARN" ]; then
      echo -e "${TIME_STAMP} [${1}]  ${2}" >> ${LOG_FILE} && echo -e "${2}"
    else    
      echo -e "${TIME_STAMP} [${1}] ${2}" >> ${LOG_FILE} && echo -e "${2}"
    fi
  fi
}

function checkFilesystem() {
  FILESYSTEM_SPACE=$(df -P ${PATH_DEST} | grep -vE '^Filesystem|tmpfs|cdrom' | awk '{print $4}')
  if [ ${FILESYSTEM_SPACE} -lt 1024000 ] ; then
    logger ERROR "There is not enough filesystem space left \"${FILESYSTEM_SPACE}kb\" you need at least \"1024000kb\", script will exit!"
    exit 1
  else 
    logger DEBUG "There is \"${FILESYSTEM_SPACE}kb\" space left on your destination directory \"${PATH_DEST}\"."
  fi
}

function checkMemoryusage() {
  MEM_FREE=$(free | grep Mem | awk '{print $4}')
  APPS_NUM=$(echo ${APPS} | wc -w)
  MEM_APP=$(echo "${MEM_FREE} / ${APPS_NUM}" | bc)
  if [ ${MEM_APP} -lt 262144 ] ; then
    logger ERROR "There is not enothe system memory avalable \"${MEM_FREE}kb\" to procedure you need at least \"262144kb\", script will exit!"
    exit 1
  else 
    logger DEBUG "There is \"${MEM_FREE}kb\" system memory avalable."
  fi
}

function installTools() {
  if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
    for PKG in ${PKG_DEBIAN} ; do
      if [[ $(cat /etc/debian_version) == "6."*"."* && ${PKG} == "git" ]] ; then
        if ! grep -R backports /etc/apt/sources* &> /dev/null ; then
          if echo "deb http://backports.debian.org/debian-backports squeeze-backports main" >> /etc/apt/sources.list ; then
            logger DEBUG "Successfully add backports repository to Debian Squeeze."
          else
            logger ERROR "Can't add backports repository to Debian Squeeze."
          fi
        fi
        # need to purge git so it's shure you get the right version
        apt-get purge ${PKG} &> /dev/null
        apt-get update &> /dev/null
        if apt-get -t squeeze-backports -y install ${PKG} &> /dev/null ; then
          logger DEBUG "Successfully installed tool \"${PKG}\"."
        else
          logger ERROR "Can't install tool \"${PKG}\", please check logfiles."
          exit 1
        fi
      else
        if ! which ${PKG} &> /dev/null ; then
          apt-get update &> /dev/null
          if apt-get install -y ${PKG} &> /dev/null ; then
            logger DEBUG "Successfully installed tool \"${PKG}\"."
          else
            logger ERROR "Can't install tool \"${PKG}\", please check logfiles."
            exit 1
          fi
        else
          logger DEBUG "Tool \"${PKG}\" is already installed."
        fi
      fi
    done
  fi
}

function installApache() {
  if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
    if ! dpkg -s apache2 &> /dev/null ; then 
      apt-get update &> /dev/null
      if apt-get install -y apache2 &> /dev/null ; then
        logger DEBUG "Successfully installed Apache Web-Server."
      else
        logger ERROR "Can't install Apache Web-Server, please check logs."
        exit 1
      fi
    else
      logger DEBUG "Apache web server is already installed."
    fi
    if a2enmod proxy proxy_http ssl rewrite &> /dev/null ; then
      logger DEBUG "Successfully loaded Apache web server modules."
    else
      logger ERROR "Can't load Apache web server modules, please have a look to the Apache logfiles."
      exit 1
    fi
    if ! grep "NameVirtualHost \*:443" /etc/apache2/ports.conf | grep -v "#" &> /dev/null ; then
      echo "NameVirtualHost *:443" >> /etc/apache2/ports.conf
      logger DEBUG "Successfully added \"NameVirtualHost *:443\" to Apache web server config."
    else
      logger DEBUG "\"NameVirtualHost *:443\" is already in Apache web server config."
    fi
    if service apache2 restart &> /dev/null ; then
      logger DEBUG "Successfully restarted Apache web server."
    else
      logger ERROR "Can't restarted Apache web server, please have a look to the Apache logfiles."
      exit 1
    fi
  fi
}

function installMySQL() {
  if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
    #if ! dpkg -s mysql-server &> /dev/null ; then 
    if ! which mysqld &> /dev/null ; then 
      apt-get update &> /dev/null
      if DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server &> /dev/null ; then
        logger DEBUG "Successfully installed MySQL-Server."
      else 
        logger ERROR "Can't install MySQL-Server, please check logs."
        exit 1
      fi
      export MYSQL_PASS=$(openssl rand -base64 18)
      if mysql -uroot -e "UPDATE mysql.user SET password=PASSWORD('${MYSQL_PASS}') WHERE user='root'; FLUSH PRIVILEGES;"; &> /dev/null ; then
        logger INFO "Successfully set MySQL root password to \"${MYSQL_PASS}\", please note it will be stored in the Logfile."
      else
        logger ERROR "Can't set MySQL-Server root password, please check logs."
        exit 1
      fi
    else
      logger DEBUG "MySQL-Server is already installed."
    fi
  fi
}

function installPostfix() {
  if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
    if ! dpkg -s postfix &> /dev/null ; then
      if DEBIAN_FRONTEND=noninteractive apt-get install -y postfix &> /dev/null ; then
        logger DEBUG "Successfully installed Postfix mailserver."
      else
        logger ERROR "Can't install Postfix mailserver, pleae check logfiles."
        exit 1
      fi
    else
      logger DEBUG "Postfix mailserver is already installed."
    fi
  fi
}

function deployDriverJDBC() {
  if ! BIN_NAME=$(wget -qO- http://dev.mysql.com/downloads/connector/j/ | grep "<td class=\"sub-text\">(" | grep "tar.gz" | cut -d"(" -f2 | cut -d")" -f1) ; then
    logger ERROR "Can't get MySQL JDBC-Drver Version from \"http://dev.mysql.com/downloads/connector/j/\"."
    exit 1
  fi
  if [ ! -f ${PATH_TEMP}/${BIN_NAME} ] ; then
    if wget http://dev.mysql.com/get/Downloads/Connector-J/${BIN_NAME}/from/http://cdn.mysql.com/ -O ${PATH_TEMP}/${BIN_NAME} &> /dev/null ; then
      logger DEBUG "Successfully downloaded \"${BIN_NAME}\" to \"${PATH_TEMP}\"."
    else
      logger ERROR "Can't download \"${BIN_NAME}\", please check url \"http://dev.mysql.com/get/Downloads/Connector-J/${BIN_NAME}/from/http://cdn.mysql.com/\"."
      exit 1
  fi
    if tar xzf ${PATH_TEMP}/${BIN_NAME} -C ${PATH_TEMP} &> /dev/null ; then
      logger DEBUG "Successfully uncompress \"${BIN_NAME}\" to \"${PATH_TEMP}\"."
    else
      logger ERROR "Can't uncompress \"${BIN_NAME}\"."
      exit 1
    fi
  fi
  if find ${PATH_DEST}/${1} -name mysql-connector-java-*.jar | xargs rm -f &> /dev/null ; then
    logger DEBUG "Successfully deleted old MySQL JDBC-Driver for the application \"${1}\"."
  fi
  if [ ${1} == "crowd" ] ; then
    if cp ${PATH_TEMP}/${BIN_NAME%.tar.gz}/${BIN_NAME%.tar.gz}-bin.jar ${PATH_DEST}/${1}/current/apache-tomcat/lib &> /dev/null ; then
      logger DEBUG "Successfully copied \"${BIN_NAME%.tar.gz}-bin.jar\" to \"${PATH_DEST}/${1}/current/apache-tomcat/lib\"."
    fi
    if chown ${1}:${1} ${PATH_DEST}/${1}/current/apache-tomcat/lib/${BIN_NAME%.tar.gz}-bin.jar &> /dev/null ; then
      logger DEBUG "Successfully chowned \"${PATH_DEST}/${1}/current/apache-tomcat/lib/${BIN_NAME%.tar.gz}-bin.jar\" to \"${1}\"."
    fi
  else
    if cp ${PATH_TEMP}/${BIN_NAME%.tar.gz}/${BIN_NAME%.tar.gz}-bin.jar ${PATH_DEST}/${1}/current/lib &> /dev/null ; then
      logger DEBUG "Successfully copied \"${BIN_NAME%.tar.gz}-bin.jar\" to \"${PATH_DEST}/${1}/current/lib\"."
    fi
    if chown ${1}:${1} ${PATH_DEST}/${1}/current/lib/${BIN_NAME%.tar.gz}-bin.jar &> /dev/null ; then
      logger DEBUG "Successfully chowned \"${PATH_DEST}/${1}/current/lib/${BIN_NAME%.tar.gz}-bin.jar\" to \"${1}\"."
    fi
  fi
}

function createDatabase() {
  if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ]; then
    if which mysqld &> /dev/null ; then
      logger DEBUG "MySQL database server is already running."
      if [ ! -n "${MYSQL_PASS}" ]; then
        logger DEBUG "MySQL database server root password variable is not set so ask for the password."
        unset MYSQL_PASS
        PROMPT="Please enter MySQL root password: "
        while IFS= read -p "${PROMPT}" -r -s -n 1 CHAR ; do
          if [[ ${CHAR} == $'\0' ]] ; then
            break
          fi
          PROMPT='*'
          MYSQL_PASS+="${CHAR}"
        done
        echo
        export MYSQL_PASS=${MYSQL_PASS}
      else
        logger DEBUG "MySQL database server root password variable is set, so no need to ask for the password."
      fi
    fi
  fi 
  if ! mysql -u root -p${MYSQL_PASS} -Bse "USE '${1}'" &> /dev/null ; then
    logger DEBUG "MySQL database \"${1}\" does not exists, so create it!"
    PASSWORD=$(openssl rand -base64 18)
    SQL_CREATE="CREATE DATABASE IF NOT EXISTS ${1} CHARACTER SET utf8 COLLATE utf8_bin;"
    SQL_GRANT="GRANT ALL ON *.* TO '${1}'@'localhost' IDENTIFIED BY '${PASSWORD}';"
    SQL_FLUSH="FLUSH PRIVILEGES;"
    if mysql -u root -p${MYSQL_PASS} -Bse "${SQL_CREATE}${SQL_GRANT}${SQL_FLUSH}" &> /dev/null ; then
      logger INFO "Successfully created database \"${1}\" with password \"${PASSWORD}\"."
    fi
  else
    logger INFO "Can't create database \"${1}\", maybe it already exists!"
  fi
}

function createCerts() {
  if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
    SSL_FOLDER="/etc/ssl/certs"
  else
    SSL_FOLDER="/etc/ssl/certs" # have to be determined
  fi 
  if ! dpkg -s openssl &> /dev/null ; then
    if apt-get install -y openssl &> /dev/null ; then
      logger DEBUG "Successfully installed openssl package."
    fi
  fi 
  if [ ! -f ${SSL_FOLDER}/${DOMAIN}.key ] && [ ! -f ${SSL_FOLDER}/${DOMAIN}.pem ] ; then
    if openssl genrsa > ${SSL_FOLDER}/${DOMAIN}.key && openssl req -new -x509 -key ${SSL_FOLDER}/${DOMAIN}.key -out ${SSL_FOLDER}/${DOMAIN}.pem -days 3650 ; then
      logger DEBUG "Successfully created Wildcard SSL Certificate."
    else
      logger ERROR "Can't create the SSL Certificate at \"${SSL_FOLDER}\"."
      exit 1
    fi
  fi
  if [ -f ${PATH_DEST}/java/current/lib/security/cacerts ] ; then
    if ! ${PATH_DEST}/java/current/bin/keytool  -list \
                                                -keystore ${PATH_DEST}/java/current/lib/security/cacerts \
                                                -storepass changeit -noprompt \
                                                -alias "${DOMAIN}" &> /dev/null ; then
      if ${PATH_DEST}/java/current/bin/keytool  -import \
                                                -trustcacerts \
                                                -keystore ${PATH_DEST}/java/current/lib/security/cacerts \
                                                -storepass changeit -noprompt \
                                                -alias "${DOMAIN}" \
                                                -file ${SSL_FOLDER}/${DOMAIN}.pem &> /dev/null ; then
        logger DEBUG "Successfully imported the wildcard SSL certificate in to Java keystore."
      else
        logger ERROR "Can't import the wildcard SSL certificate in to Java keystore."
        exit 1
      fi 
    else
      logger DEBUG "Wildcard SSL Certificate already imported in to Java keystore."
    fi
  else
    logger ERROR "Java keystore \"${PATH_DEST}/java/current/lib/security/cacerts.\" does not exists, can't import."
    exit 1
  fi
}

function createVhost() {
  if [ ! ${1} == "fisheye" ]; then
    TOMCAT_CONFIG=$(find ${PATH_DEST}/${1} -name server.xml)
    TOMCAT_PORT=$(xmlstarlet sel -t -m Server/Service/Connector -v @port ${TOMCAT_CONFIG})
  else
    TOMCAT_CONFIG=$(find ${PATH_DEST}/${1} -name config.xml)
    TOMCAT_PORT=$(xmlstarlet sel -t -m config/web-server/http -v @bind ${TOMCAT_CONFIG} | cut -d: -f2)
  fi
  if [ ${ALT_NAMES} -eq 1 ] ; then
    if [ ${1} == "jira" ]; then
        APP_NAME="projects"
    elif [ ${1} == "confluence" ]; then
        APP_NAME="wiki"
    elif [ ${1} == "stash" ]; then
        APP_NAME="git"
    elif [ ${1} == "fisheye" ]; then
        APP_NAME="repo"
    elif [ ${1} == "crowd" ]; then
        APP_NAME="id"
    fi
  else
    APP_NAME=${1}
  fi
  if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
    VHOST_FILE="/etc/apache2/sites-available/${1}"
    SSL_FOLDER="/etc/ssl/certs"
  else
    VHOST_FILE="/etc/httpd/conf.d/${1}"
    SSL_FOLDER="/etc/ssl/certs" # have to be determined
  fi 
  if [ ${EXT_PROXY} -eq 1 ] ; then
    SERVER_IP=$(ifconfig eth0 | grep "inet addr" | awk -F':' '{print $2}' | awk '{print $1}')
  else
    SERVER_IP='127.0.0.1'
  fi
  APACHE_LOG_DIR='${APACHE_LOG_DIR}'
  VHOST_CONFIG=$(cat << EOF
<VirtualHost *:80>
  ServerName        ${APP_NAME}.${DOMAIN}
  ServerAdmin       webmaster@${DOMAIN}
  ServerSignature   Off
 
  ErrorLog          ${APACHE_LOG_DIR}/${1}_error.log
  CustomLog         ${APACHE_LOG_DIR}/${1}_access.log combined
  LogLevel          warn
 
  RewriteEngine     On
  RewriteCond       %{HTTPS} off
  RewriteRule       ^/?(.*) https://%{HTTP_HOST}%{REQUEST_URI}
</VirtualHost>
 
<VirtualHost *:443>
  ServerName        ${APP_NAME}.${DOMAIN} 
  ServerAdmin       webmaster@${DOMAIN}
  ServerSignature   Off
 
  SSLEngine         On
  SSLProtocol       -all +SSLv3 +TLSv1
  SSLCipherSuite    SSLv3:+HIGH:+MEDIUM
  # PLEASE CHANGE THAT PART TO YOUR NEEDS
  SSLCertificateFile ${SSL_FOLDER}/${DOMAIN}.pem
  SSLCertificateKeyFile ${SSL_FOLDER}/${DOMAIN}.key
  #SSLCertificateChainFile ${SSL_FOLDER}/gd_bundle.crt
 
  ErrorLog          ${APACHE_LOG_DIR}/${1}_error.log
  CustomLog         ${APACHE_LOG_DIR}/${1}_access.log combined
  LogLevel          warn

  RewriteEngine     On
  RewriteLogLevel   0
  RewriteLog        ${APACHE_LOG_DIR}/${1}_rewrite.log

  ProxyRequests     Off
  ProxyPreserveHost On
   
  <Proxy *>
    Order deny,allow
    Allow from all
  </Proxy>
        
  ProxyPass         / http://${SERVER_IP}:${TOMCAT_PORT}/
  ProxyPassReverse  / http://${SERVER_IP}:${TOMCAT_PORT}/

  <Location />
    Order allow,deny
    Allow from all
  </Location>
</VirtualHost>
EOF
)
  if [ ${EXT_PROXY} -ne 1 ] ; then
    if [ ! -f ${VHOST_FILE} ]; then
      if echo "${VHOST_CONFIG}" > ${VHOST_FILE} ; then
        logger DEBUG "Created Apache vhost config for \"${1}\"."
      else
        logger DEBUG "Apache vhost config for \"${1}\" already exists."
      fi
    fi
    if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
      if a2ensite ${1} &> /dev/null ; then
        logger DEBUG "Successfully enabled Apache vhost config for \"${1}\"."
      else 
        logger ERROR "Can't enabled Apache vhost config for \"${1}\", something went wrong."
        exit 1
      fi
      if service apache2 reload &> /dev/null ; then
        logger DEBUG "Successfully reload Apache web server for the new config."
      else 
        logger ERROR "Can't reload Apache web server for the new config."
        exit 1
      fi
    fi
  else
    logger INFO "Save the config to your Proxy-Server \"${VHOST_FILE}\" and change the SSL settings. \n\n${VHOST_CONFIG}\n"
  fi    
}

function purgeVhost() {
  if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
    VHOST_FILE="/etc/apache2/sites-available/${1}"
  else
    VHOST_FILE="/etc/httpd/conf.d/${1}"
  fi 
  if [ -f ${VHOST_FILE} ]; then
    logger DEBUG "Found Apache vhost config \"${VHOST_FILE}\"."
    if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
      if a2dissite ${1} &> /dev/null ; then
        logger DEBUG "Successfully disable Apache vhost config for \"${1}\"."
        if rm -f /etc/apache2/sites-available/${1} &> /dev/null ; then
          logger DEBUG "Successfully removed Apache vhost config for \"${1}\"."
        fi
        if service apache2 reload &> /dev/null ; then
          logger DEBUG "Successfully reload Apache vhost config."
        else 
          logger ERROR "Can't reload Apache vhost config."
          exit 1
        fi
      else
        logger ERROR "Can't disable Apache vhost config for \"${1}\"."
        exit 1
      fi
    fi
  fi 
}

function createFolders() {
  if [ ! -d ${PATH_DEST}/${1} ] ; then
    if mkdir -p ${PATH_DEST}/${1} &> /dev/null ; then
      logger DEBUG "Successfully created folder \"${PATH_DEST}/${1}\"."
    else
      logger ERROR "Can't create folder \"${PATH_DEST}/${1}\"."
      exit 1
    fi
  else 
    logger DEBUG "Folder \"${PATH_DEST}/${1}\" already exists."
  fi
  if [ ! -d ${PATH_BACKUP} ] ; then
    if mkdir -p ${PATH_BACKUP} &> /dev/null ; then
      logger DEBUG "Successfully created folder \"${PATH_BACKUP}\"."
    else
      logger ERROR "Can't create folder \"${PATH_BACKUP}\"."
      exit 1
    fi
  else 
    logger DEBUG "Folder \"${PATH_BACKUP}\" already exists."
  fi
}

function purgeFolders() {
  if [ -d ${PATH_DEST}/${1} ] ; then
    if rm -rf ${PATH_DEST}/${1} &> /dev/null ; then
      logger DEBUG "Successfully removed folder \"${PATH_DEST}/${1}\"."
    fi
  fi
}

function createCredentials() {
  if ! id -u ${1} &> /dev/null ; then
    logger DEBUG "User \"${1}\" and group \"${1}\" does not exists."
    if groupadd ${1} &> /dev/null ; then
      logger DEBUG "Successfully created group \"${1}\"."
    else
      logger ERROR "Can't created group \"${1}\"."
      exit 1
    fi 
    if useradd -s /bin/bash -r -m -g ${1} -d ${PATH_DATA} ${1} &> /dev/null ; then
      logger DEBUG "Successfully created user \"${1}\"."
    else
      logger ERROR "Can't created user \"${1}\"."
      exit 1
    fi 
  fi
}

function setEnvirement() {
  if [ -f "${PATH_DATA}/.profile" ] ; then
    if ! grep JAVA_HOME "${PATH_DATA}/.profile" >/dev/null 2>&1 ; then
      echo "export JAVA_HOME=${PATH_DEST}/java/current" >> "${PATH_DATA}/.profile"
      echo "export PATH=$PATH:${PATH_DEST}/java/current/bin" >> "${PATH_DATA}/.profile"
      if [ ${1} == "stash" ] ; then
        echo "export STASH_HOME=${PATH_DATA}/${1}" >> "${PATH_DATA}/.profile"
      fi
      logger DEBUG "Successfully added Java envirements to \".profile\"."
    fi
  else
    logger ERROR "Profile of user \"${1}\" does not exits."
    exit 1
  fi
}

function purgeCredentials() {
  if id -u ${1} &> /dev/null ; then
    if userdel -f ${1} &> /dev/null ; then
      logger DEBUG "Successfully deleted user \"${1}\"."
    fi
  fi
}

function purgeJava() {
  if [ -d "${PATH_DEST}/java" ] ; then
    if rm -rf "${PATH_DEST}/java" ; then 
      logger DEBUG "Successfully deleted \"${PATH_DEST}/java\" folder."
    fi
  fi
}

function stopApp() {
  PID=$(ps -ef | grep ${1} | grep -v -e "grep" -e "$(basename $0)" | awk '{print $2}')
  if [ ! "x${PID}" == "x" ] ; then
    while ps ef ${PID} &> /dev/null ; do
      kill ${PID} &> /dev/null
      sleep 2
    done
    logger INFO "Successfully stopped application \"${1}\" with pid \"${PID}\"."
  fi
}

function startApp() {
  PID=$(ps -ef | grep ${1} | grep -v -e "grep" -e "$(basename $0)" | awk '{print $2}')
  if [ "x${PID}" == "x" ] ; then
    SCRIPT_START=$(find ${PATH_DEST}/${1}/current/ -name start\*.sh | grep -v '-')
    if su ${1} -l -c "${SCRIPT_START} &> /dev/null" ; then
      logger INFO "Successfully started application \"${1}\"."
    else 
      logger ERROR "Can't start application \"${1}\"."
      exit 1
    fi
  fi
}

function deployLatestJava() {
  if [ ! -d "${PATH_DEST}/java" ] ; then
    if mkdir "${PATH_DEST}/java" ; then
      logger DEBUG "Sucessfully created folder \"${PATH_DEST}/java\"."
    else
      logger ERROR "Can't created folder \"${PATH_DEST}/java\"."
      exit 1
    fi
  else
    logger DEBUG "Folder \"${PATH_DEST}/java\" already exit's and can't be created."
  fi
  if [ ${ARCH} -eq 64 ] ; then
    DOWNLOAD=$(wget -qO- http://www.java.com/en/download/manual.jsp | \
               grep "title=\" Download Java software for Linux x64\" href" | \
               grep -v RPM | uniq | awk -F"href=\"" '{print $2}' | \
               awk -F"\" onclick" '{print $1}')
    logger DEBUG "Download \"${ARCH}bit\" version of Java's JRE."
  elif [ ${ARCH} -eq 32 ] ; then
    DOWNLOAD=$(wget -qO- http://www.java.com/en/download/manual.jsp | \
               grep "title=\" Download Java software for Linux\" href" | \
               grep -v RPM | uniq | awk -F"href=\"" '{print $2}' | \
               awk -F"\" onclick" '{print $1}')
    logger DEBUG "Download \"${ARCH}bit\" version of Java's JRE."
  fi
  if [ -f ${PATH_TEMP}/jre-linux.tar.gz ] ; then
    rm -f ${PATH_TEMP}/jre-linux.tar.gz
  fi
  if wget ${DOWNLOAD} -O ${PATH_TEMP}/jre-linux.tar.gz &> /dev/null ; then
    logger DEBUG "Successfully download Java JRE \"${PATH_TEMP}/jre-linux.tar.gz\"."
  else
    logger ERROR "Can't download Java JRE from \"${DOWNLOAD}\"."
    exit 1
  fi
  JAVA_VERSION=$(tar -tzf ${PATH_TEMP}/jre-linux.tar.gz 2> /dev/null | head -1 | cut -d"/" -f1)
  if [ ! -d ${PATH_DEST}/java/${JAVA_VERSION} ] ; then
    logger DEBUG "Java JRE \"${JAVA_VERSION}\" does not exits at the destination folder \"${PATH_DEST}/java\"."
    if tar -xzf ${PATH_TEMP}/jre-linux.tar.gz -C "${PATH_DEST}/java" &> /dev/null ; then
      logger DEBUG "Successfully extract \"${PATH_TEMP}/jre-linux.tar.gz\"."
    else
      logger ERROR "Can't extract \"${PATH_TEMP}/jre-linux.tar.gz\" it sems to be corrupt, script will exit."
      exit 1
    fi
    if ln -fs ${PATH_DEST}/java/${JAVA_VERSION} ${PATH_DEST}/java/current &> /dev/null ; then
      logger DEBUG "Successfully set softlink \"${PATH_DEST}/java/${JAVA_VERSION}\" to \"${PATH_DEST}/java/current\"."
    fi
  fi
  if [ -L ${PATH_DEST}/java/current ] ; then
    if chown -R root:root ${PATH_DEST}/java/current/ &> /dev/null ; then
      logger DEBUG "Successfully chownd \"${PATH_DEST}/java/current\" to \"root\"."
    fi
  else
    logger ERROR "Can't find \"${PATH_DEST}/java/current\"."
    exit 1
  fi
  if rm -f ${PATH_TEMP}/jre-linux.tar.gz &> /dev/null ; then
    logger DEBUG "Successfully removed \"${PATH_TEMP}/jre-linux.tar.gz\" archive."
  fi
}
 
function showApp() {
  BIN_URL=$(wget -qO- https://my.atlassian.com/download/feeds/current/${1}.json | \
            grep -Po '"zipUrl":.*?[^\\]",'  | \
            grep tar.gz | \
            grep -v cluster | \
            grep -v "\-war." | \
            cut -d"\"" -f4)
  FILE_NAME=$(echo ${BIN_URL} | cut -d"/" -f8 )
  FOLDER_NAME=${FILE_NAME%.tar.gz}
  if [ ! "x${FOLDER_NAME}" == "x" ] ; then
    logger INFO "Latest availalble version is \"${FOLDER_NAME}\"."
  else
    logger ERROR "Can't get version from \"https://my.atlassian.com/download/feeds/current/${1}.json\", script will exit."
    exit 1
  fi
  if [ -L ${PATH_DEST}/${1}/current ]; then
    INSTALLED_VERSION="$(basename $(readlink ${PATH_DEST}/${1}/current))"
    logger INFO "Installed version is \"${INSTALLED_VERSION}\"."
  fi
}

function deployLatestBin() {
  if [ ! ${1} == "fisheye" ]; then
    BIN_URL=$(wget -qO- https://my.atlassian.com/download/feeds/current/${1}.json | \
              grep -Po '"zipUrl":.*?[^\\]",'  | \
              grep tar.gz | \
              grep -v cluster | \
              grep -v "\-war." | \
              cut -d"\"" -f4)
    FILE_NAME=$(echo ${BIN_URL} | cut -d"/" -f8 )
    FOLDER_NAME=${FILE_NAME%.tar.gz}
  else
    BIN_URL=$(wget -qO- https://my.atlassian.com/download/feeds/current/${1}.json | \
              grep -Po '"zipUrl":.*?[^\\]",'  | \
              grep zip | \
              cut -d"\"" -f4)
    FILE_NAME=$(echo ${BIN_URL} | cut -d"/" -f8 )
    FOLDER_NAME=${FILE_NAME%.zip}
    FISHEYE_VERSION=$(echo ${FOLDER_NAME} | cut -d'-' -f2)
  fi
  if [ ! "x${FOLDER_NAME}" == "x" ] ; then
    logger DEBUG "Latest availalble version is \"${FOLDER_NAME}\"."
  else
    logger ERROR "Can't get version from \"https://my.atlassian.com/download/feeds/current/${1}.json\", script will exit."
    exit 1
  fi
  if [ ! -f ${PATH_TEMP}/${FILE_NAME} ] ; then
    logger DEBUG "Binary of ${1} does not exists in \"${PATH_TEMP}/${FILE_NAME}\", so start download."
    if wget ${BIN_URL} -P ${PATH_TEMP} &> /dev/null ; then
      logger DEBUG "Successfully downloaded \"${BIN_URL}\"."
    else
      logger ERROR "Can't downloaded \"${BIN_URL}\", script will exit."
      exit 1
    fi
  fi
  CHECK_VERSION=$(find ${PATH_DEST}/${1}/ -name ${FOLDER_NAME}\*)
  if [ "x${CHECK_VERSION}" == "x" ] ; then 
    logger DEBUG "Version \"${FOLDER_NAME}\" does not exists, so continue."
    if [ -f ${PATH_TEMP}/${FILE_NAME} ] ; then
      if [ ! ${1} == "fisheye" ]; then 
        if tar -xzvf ${PATH_TEMP}/${FILE_NAME} -C ${PATH_DEST}/${1} &> /dev/null ; then
          logger DEBUG "Successfully uncompress \"${PATH_TEMP}/${FILE_NAME}\" to \"${PATH_DEST}/${1}\"."
        else
          logger ERROR "Can't uncompress \"${PATH_TEMP}/${FILE_NAME}\" to \"${PATH_DEST}/${1}\"."
          exit 1
        fi
      else
        if unzip ${PATH_TEMP}/${FILE_NAME} -d ${PATH_DEST}/${1} &> /dev/null && mv ${PATH_DEST}/${1}/*-${FISHEYE_VERSION} ${PATH_DEST}/${1}/fisheye-${FISHEYE_VERSION} &> /dev/null ; then
          logger DEBUG "Successfully uncompress \"${PATH_TEMP}/${FILE_NAME}\" to \"${PATH_DEST}/${1}\"."
        else
          logger ERROR "Can't uncompress \"${PATH_TEMP}/${FILE_NAME}\" to \"${PATH_DEST}/${1}\"."
          exit 1
        fi
      fi
    fi
    if [ ${1} == "jira" ] ; then
      APP_PATH="${PATH_DEST}/${1}/${FOLDER_NAME}-standalone"
    else
      APP_PATH="${PATH_DEST}/${1}/${FOLDER_NAME}"
    fi
    if [ -L ${PATH_DEST}/${1}/current ]; then
      if unlink ${PATH_DEST}/${1}/current ; then
        logger DEBUG "Successfully unlink \"${PATH_DEST}/${1}/current\"."
      else
        logger ERROR "Can't unlink \"${PATH_DEST}/${1}/current\"."
        exit 1
      fi
    fi
    if ln -s ${APP_PATH} ${PATH_DEST}/${1}/current ; then
      logger DEBUG "Successfully set softlink to \"${PATH_DEST}/${1}/current\"."
    else
      logger ERROR "Can't set softlink to \"${PATH_DEST}/${1}/current\"."
      exit 1
    fi
    if [ -L ${PATH_DEST}/${1}/current ]; then
      if chown -R ${1}:${1} "${PATH_DEST}/${1}/current/"; then
        logger DEBUG "Successfully chownd \"${PATH_DEST}/${1}/current\"."
      else
        logger ERROR "Can't chown \"${PATH_DEST}/${1}/current\"."
        exit 1
      fi
    else
      logger ERROR "Can't find \"${PATH_DEST}/${1}/current\"."
      exit 1
    fi
  else
    logger WARN "Version \"${FOLDER_NAME}\" does already exists, so do nothing."
  fi
  for BIN_FOLDERS in $(ls ${PATH_DEST}/${1} | grep -v -e backup -e current -e data | head -n-${MAX_BINS}) ; do
    if rm -rf ${PATH_DEST}/${1}/${BIN_FOLDERS} &> /dev/null ; then
      logger DEBUG "Successfully deleted old binary deployments \"${BIN_FOLDERS}\"."
    else
      logger DEBUG "Can't deleted old binary deployments \"${BIN_FOLDERS}\"."
    fi
  done
}

function configTomcatProxy() {
  if [ ! ${1} == "fisheye" ]; then
    TOMCAT_CONFIG=$(find ${PATH_DEST}/${1}/current/ -name server.xml)
  else
    TOMCAT_CONFIG=$(find ${PATH_DEST}/${1}/current/ -name config.xml)
  fi
  if [ ${ALT_NAMES} -eq 1 ] ; then
    if [ ${1} == "jira" ]; then
        APP_NAME="projects"
    elif [ ${1} == "confluence" ]; then
        APP_NAME="wiki"
    elif [ ${1} == "stash" ]; then
        APP_NAME="git"
    elif [ ${1} == "fisheye" ]; then
        APP_NAME="repo"
    elif [ ${1} == "crowd" ]; then
        APP_NAME="id"
    fi
  else
    APP_NAME=${1}
  fi
  if [ -f ${TOMCAT_CONFIG} ]; then
    if [ "${TOMCAT_CONFIG}x" != "x" ]; then
      if ! grep ${DOMAIN} ${TOMCAT_CONFIG} &> /dev/null ; then
        if [ "${1}" != "fisheye" ] ; then
          if xmlstarlet ed -L -PS -u "/Server/Service/Engine/Host/Context/@path" -v "" ${TOMCAT_CONFIG} &> /dev/null ; then
            logger DEBUG "Successfully set application context path for \"${1}\"."
          else
            logger ERROR "Can't set set application context path for \"${1}\"."
            exit 1
          fi
          if xmlstarlet ed -L -PS -u "/Server/Service/Connector/@connectionTimeout" -v "120000" ${TOMCAT_CONFIG} &> /dev/null ; then
            logger DEBUG "Successfully set application proxy timeout for \"${1}\"."
          else
            logger ERROR "Can't set set application proxy timeout for \"${1}\"."
            exit 1
          fi
          if xmlstarlet ed -L -PS -s /Server/Service/Connector -t attr -n proxyName -v ${APP_NAME}.${DOMAIN} ${TOMCAT_CONFIG} &> /dev/null ; then
            logger DEBUG "Successfully set application proxy name for \"${1}\"."
          else
            logger ERROR "Can't set set application proxy name for \"${1}\"."
            exit 1
          fi
          if xmlstarlet ed -L -PS -s /Server/Service/Connector -t attr -n proxyPort -v 443 ${TOMCAT_CONFIG} &> /dev/null ; then
            logger DEBUG "Successfully set application proxy port path for \"${1}\"."
          else
            logger ERROR "Can't set set application proxy port for \"${1}\"."
            exit 1
          fi
          if xmlstarlet ed -L -PS -s /Server/Service/Connector -t attr -n scheme -v https ${TOMCAT_CONFIG} &> /dev/null ; then
            logger DEBUG "Successfully set application proxy scheme for \"${1}\"."
          else
            logger ERROR "Can't set set application proxy scheme for \"${1}\"."
            exit 1
          fi
          if [ ${EXT_PROXY} -ne 1 ] ; then
            if xmlstarlet ed -L -PS -s /Server/Service/Connector -t attr -n address -v "127.0.0.1" ${TOMCAT_CONFIG} &> /dev/null ; then
              logger DEBUG "Successfully set application interface address for \"${1}\"."
            else
              logger ERROR "Can't set set application interface address for \"${1}\"."
              exit 1
            fi
          fi
        else
          if xmlstarlet ed -L -PS -s /config/web-server/http -t attr -n proxy-host -v ${APP_NAME}.${DOMAIN} ${TOMCAT_CONFIG} &> /dev/null ; then
            logger DEBUG "Successfully set application proxy name for \"${1}\"."
          else
            logger ERROR "Can't set set application proxy name for \"${1}\"."
            exit 1
          fi
          if xmlstarlet ed -L -PS -s /config/web-server/http -t attr -n proxy-port -v 443 ${TOMCAT_CONFIG} &> /dev/null ; then
            logger DEBUG "Successfully set application proxy port path for \"${1}\"."
          else
            logger ERROR "Can't set set application proxy port for \"${1}\"."
            exit 1
          fi
          if xmlstarlet ed -L -PS -s /config/web-server/http -t attr -n proxy-scheme -v https ${TOMCAT_CONFIG} &> /dev/null ; then
            logger DEBUG "Successfully set application proxy scheme for \"${1}\"."
          else
            logger ERROR "Can't set set application proxy scheme for \"${1}\"."
            exit 1
          fi
          if [ ${EXT_PROXY} -ne 1 ] ; then
            TOMCAT_PORT=$(xmlstarlet sel -t -m config/web-server/http -v @bind ${TOMCAT_CONFIG} | cut -d: -f2)
            if xmlstarlet ed -L -PS -u "/config/web-server/http/@bind" -v "127.0.0.1:${TOMCAT_PORT}" ${TOMCAT_CONFIG} &> /dev/null ; then
              logger DEBUG "Successfully set application interface address for \"${1}\"."
            else
              logger ERROR "Can't set set application interface address for \"${1}\"."
              exit 1
            fi
          fi
        fi
      else
        logger DEBUG "The Tomcat config \"${TOMCAT_CONFIG}\" is already configured."
      fi
    fi
  fi
}

function setHomes() {
  if [ ${1} == "crowd" ]; then
    if echo "${1}.home=${PATH_DATA}" > ${PATH_DEST}/${1}/current/${1}-webapp/WEB-INF/classes/${1}-init.properties ; then
      logger DEBUG "Successfully add home path to \"${1}\" config."
    else
      logger ERROR "Can't add home path to \"${1}\" config."
      exit 1
    fi
  elif [ ${1} == "confluence" ]; then
    if echo "${1}.home=${PATH_DATA}" > ${PATH_DEST}/${1}/current/${1}/WEB-INF/classes/${1}-init.properties ; then
      logger DEBUG "Successfully add home path to \"${1}\" config."
    else
      logger ERROR "Can't add home path to \"${1}\" config."
      exit 1
    fi
  elif [ ${1} == "jira" ]; then
    if echo "${1}.home=${PATH_DATA}" > ${PATH_DEST}/${1}/current/atlassian-${1}/WEB-INF/classes/${1}-application.properties ; then
      logger DEBUG "Successfully add home path to \"${1}\" config."
    else
      logger ERROR "Can't add home path to \"${1}\" config."
      exit 1
    fi
  fi
}

getServerMemory(){
  export APP_MEM_FREE="$(echo "($(free -l | grep "Mem:" | awk '{print $4}') / $(echo "${APPS} mysql" | wc -w)) / 1024"  | bc)"
  export APP_MEM_PERM="$(echo "${APP_MEM_FREE} / 5" | bc)"
  export APP_MEM_HEAP="$(echo "${APP_MEM_PERM} * 4" | bc)"
  if [ "${APP_MEM_PERM}" -lt "256" ]; then 
    export APP_MEM_PERM="256"
  fi
}

function serverMemorycalc() {
  APP_MEM_FREE="$(echo "($(free -l | grep "Mem:" | awk '{print $4}') / $(echo "${APPS} mysql" | wc -w)) / 1024"  | bc)"
  APP_MEM_PERM="$(echo "${APP_MEM_FREE} / 5" | bc)"
  APP_MEM_HEAP="$(echo "${APP_MEM_PERM} * 4" | bc)"
  if [ "${APP_MEM_PERM}" -lt "256" ]; then 
    APP_MEM_PERM="256"
  fi
  if [ ${1} == "jira" ]; then
    if sed "s/JVM_MAXIMUM_MEMORY=\"[0-9]*m\"/JVM_MAXIMUM_MEMORY=\"${APP_MEM_HEAP}m\"/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh && \
       sed "s/JVM_MINIMUM_MEMORY=\"[0-9]*m\"/JVM_MINIMUM_MEMORY=\"${APP_MEM_HEAP}m\"/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh && \
       sed "s/JIRA_MAX_PERM_SIZE=[0-9]*m/JIRA_MAX_PERM_SIZE=\"${APP_MEM_PERM}m\"/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh; then
      logger DEBUG "Successfully changed memory setting of \"${1}\"."
    else
      logger ERROR "Can't change memory setting of \"${1}\"."
      exit 1
    fi
  elif [ ${1} == "stash" ]; then
    if sed "s/JVM_MAXIMUM_MEMORY=\"[0-9]*m\"/JVM_MAXIMUM_MEMORY=\"${APP_MEM_HEAP}m\"/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh && \
       sed "s/JVM_MINIMUM_MEMORY=\"[0-9]*m\"/JVM_MINIMUM_MEMORY=\"${APP_MEM_HEAP}m\"/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh && \
       sed "s/STASH_MAX_PERM_SIZE=[0-9]*m/STASH_MAX_PERM_SIZE=\"${APP_MEM_PERM}m\"/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh; then
      logger DEBUG "Successfully changed memory setting of \"${1}\"."
    else
      logger ERROR "Can't change memory setting of \"${1}\"."
      exit 1
    fi
  elif [ ${1} == "crowd" ]; then
    if sed "s/Xms[0-9]*m/Xms${APP_MEM_HEAP}m/g" -i ${PATH_DEST}/${1}/current/apache-tomcat/bin/setenv.sh && \
       sed "s/Xmx[0-9]*m/Xmx${APP_MEM_HEAP}m/g" -i ${PATH_DEST}/${1}/current/apache-tomcat/bin/setenv.sh && \
       sed "s/MaxPermSize=[0-9]*m/MaxPermSize=${APP_MEM_PERM}m/g" -i ${PATH_DEST}/${1}/current/apache-tomcat/bin/setenv.sh ; then
      logger DEBUG "Successfully changed memory setting of \"${1}\"."
    else
      logger ERROR "Can't change memory setting of \"${1}\"."
      exit 1
    fi
  elif [ ${1} == "confluence" ]; then
    if sed "s/Xms[0-9]*m/Xms${APP_MEM_HEAP}m/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh && \
       sed "s/Xmx[0-9]*m/Xmx${APP_MEM_HEAP}m/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh && \
       sed "s/MaxPermSize=[0-9]*m/MaxPermSize=${APP_MEM_PERM}m/g" -i ${PATH_DEST}/${1}/current/bin/setenv.sh; then
      logger DEBUG "Successfully changed memory setting of \"${1}\"."
    else
      logger ERROR "Can't change memory setting of \"${1}\"."
      exit 1
    fi
  fi
}

function setFixes() {
  if [ ${1} == "crowd" ] ; then
    if [ -f "${PATH_DEST}/crowd/current/apache-tomcat/bin/setenv.sh" ] ; then
      if [ ! $(grep CATALINA_PID "${PATH_DEST}/crowd/current/apache-tomcat/bin/setenv.sh" &> /dev/null) ] ; then
        cat >> ${PATH_DEST}/crowd/current/apache-tomcat/bin/setenv.sh << 'EOF'
# set the location of the pid file
if [ -z "$CATALINA_PID" ] ; then
    if [ -n "$CATALINA_BASE" ] ; then
        CATALINA_PID="$CATALINA_BASE"/work/catalina.pid
    elif [ -n "$CATALINA_HOME" ] ; then
        CATALINA_PID="$CATALINA_HOME"/work/catalina.pid
    fi
fi
export CATALINA_PID

PRGDIR=`dirname "$0"`
if [ -z "$CATALINA_BASE" ]; then
  if [ -z "$CATALINA_HOME" ]; then
    LOGBASE=$PRGDIR
    LOGTAIL=..
  else
    LOGBASE=$CATALINA_HOME
    LOGTAIL=.
  fi
else
  LOGBASE=$CATALINA_BASE
  LOGTAIL=.
fi

PUSHED_DIR=`pwd`
cd $LOGBASE
cd $LOGTAIL
LOGBASEABS=`pwd`
cd $PUSHED_DIR

echo ""
echo "Server startup logs are located in $LOGBASEABS/logs/catalina.out"
EOF
        if [ $? -eq 0 ]; then
          logger DEBUG "Successfully run fixes on \"${1}\"."
        else
          logger ERROR "Can't run fixes on \"${1}\"."
          exit 1
        fi
      fi
    fi
  fi
}

function backupDatabase() { 
  if [ ${1} == "jira" ]; then
    APP_CONFIG=$(find ${PATH_DATA}/ -name dbconfig.xml)
    if [ ! "x${APP_CONFIG}" == "x" ] ; then
      logger DEBUG "found application config ${APP_CONFIG}"
      MYSQL_PASSWORD=$(grep password ${APP_CONFIG} | cut -d">" -f2 | cut -d"<" -f1)
    else
      logger ERROR "Can't find database configuration file for \"${1}\"."
      exit 1
    fi
  elif [ ${1} == "stash" ]; then
    APP_CONFIG=$(find ${PATH_DATA}/ -name stash-config.properties)
    if [ ! "x${APP_CONFIG}" == "x" ] ; then  
      logger DEBUG "found application config ${APP_CONFIG}"
      MYSQL_PASSWORD=$(grep password ${APP_CONFIG} | cut -d"=" -f2)
    else
      logger ERROR "Can't grep database password for \"${1}\"."
      exit 1
    fi
  else
    APP_CONFIG=$(find ${PATH_DATA}/ -name ${1}.cfg.xml)
    if [ ! "x${APP_CONFIG}" == "x" ] ; then
      logger DEBUG "Found application config \"${APP_CONFIG}\"."
      MYSQL_PASSWORD=$(grep hibernate.connection.password ${APP_CONFIG} | cut -d">" -f2 | cut -d"<" -f1)
    else
      logger ERROR "Can't grep database credentials from \"${1}\" config."
      exit 1
    fi
  fi
  if [ ! "x${MYSQL_PASSWORD}" == "x" ] ; then
    if mysqldump -u${1} -p${MYSQL_PASSWORD} ${1} --add-drop-database > ${PATH_DATA}/${1}_database_backup.sql ; then
      logger INFO "Successfully dumped \"${1}\" to \"${PATH_DATA}/${1}_database_backup.sql\"."
    else
      logger ERROR "Can't dump \"${1}\" database backup."
      exit 1
    fi
    if chown ${1}:${1} ${PATH_DATA}/${1}_database_backup.sql &> /dev/null ; then
      logger DEBUG "Successfully owned database dump from ${1}"
    else
      logger ERROR "Can't own database dump from \"${1}\"."
      exit 1
    fi
  else
    logger ERROR "Can't grep database credentials from \"${1}\" config."
    exit 1
  fi
  unset MYSQL_PASSWORD
}

function backupHome() {
  if [ -d "${PATH_DEST}/${1}" ] && [ -d ${PATH_BACKUP} ] ; then
    if tar -czf ${PATH_BACKUP}/${1}_backup_${TIMESTAMP}.tgz --exclude="${PATH_BACKUP}" ${PATH_DEST}/${1} &> /dev/null ; then
      logger INFO "Successfully backup \"${1}\" home folder."
    else
      logger ERROR "Can't backup \"${1}\" home folder."
      exit 1
    fi
    if rm -f ${PATH_DATA}/${1}_database_backup.sql &> /dev/null ; then
      logger DEBUG "Delete old \"${1}\" database dump."
    fi
    for FILE in $(ls ${PATH_BACKUP}/${1}_backup_*.tgz | head -n-${MAX_BACKUPS}) ; do
      if rm -f ${FILE} &> /dev/null ; then
        logger DEBUG "Deleted old backup file \"${FILE}\"."
      fi
    done
  fi
}

function deployInitScript() {
  if [ ! -f /etc/init.d/${1} ] ; then
    SCRIPT_START=$(find ${PATH_DEST}/${1}/current/ -name start\*.sh | grep -v '-')
    SCRIPT_STOP=$(find ${PATH_DEST}/${1}/current/ -name stop\*.sh)
    if [ ! "x${SCRIPT_START}" == "x" ] || [ ! "x${SCRIPT_STOP}" == "x" ] ; then
      HELPER_VARIABLE='$1'
      cat >> /etc/init.d/${1} << EOF
#!/bin/sh -e
# ${1} startup script
#chkconfig: 2345 80 05
#description: ${1}
 
export JAVA_HOME=${PATH_DEST}/java/current
 
case "${HELPER_VARIABLE}" in
  # Start command
  start)
    echo "Starting ${1}"
    /bin/su ${1} -l -c "${SCRIPT_START} &> /dev/null"
    ;;
  # Stop command
  stop)
    echo "Stopping ${1}"
    /bin/su ${1} -l -c "${SCRIPT_STOP} &> /dev/null"
    echo " stopped successfully"
    ;;
  # Restart command
  restart)
    /etc/init.d/${1} stop
    sleep 5
    /etc/init.d/${1} start
    ;;
  *)
    echo "Usage: /etc/init.d/${1} {start|restart|stop}"
    exit 1
    ;;
esac
 
exit 0
EOF
      if [ $? -eq 0 ]; then
        logger DEBUG "Successfully created init script for \"${1}\"."
      else
        logger ERROR "Can't created init script for \"${1}\"."
        exit 1
      fi
      if chmod +x /etc/init.d/${1} &> /dev/null ; then
        logger DEBUG "Successfully make init script for \"${1}\" executeble."
      else
        logger ERROR "Can't make init script for \"${1}\" executeble."
        exit 1
      fi
    fi
    if [ ${DISTRO} == "Ubuntu" ] || [ ${DISTRO} == "debian" ] ; then
      if update-rc.d ${1} defaults &> /dev/null ; then
        logger DEBUG "Successfully enabled \"${1}\" for automatic startup."
      else
        logger ERROR "Can't enabled \"${1}\" for automatic startup."
        exit 1
      fi
    elif [ ${DISTRO} == "redhat" ] ; then
      chkconfig --add ${1} >/dev/null 2>&1
    fi
  fi
}

function purgeInitScript() {
  if [ -f /etc/init.d/${1} ] ; then
    if rm -f /etc/init.d/${1} &> /dev/null ; then
      logger DEBUG "Successfully delete \"${1}\" init script."
    else
      logger ERROR "Successfully delete \"${1}\" init script."
      exit 1
    fi
  fi
}

function restoreLatestData() {
  BACKUPLATEST=$(ls ${PATH_BACKUP}/*.tgz | sort -rn | head -n1)
  if tar -tzf ${BACKUPLATEST} &> /dev/null ; then
    logger DEBUG "Last backup ${BACKUPLATEST} is validated to restore."
    if find ${PATH_DEST}/${1}/* -maxdepth 0 | grep -v ${PATH_BACKUP} | xargs rm -rf &> /dev/null ; then
      logger DEBUG "Successfully removed \"${1}\" files for the restore."
      if tar -xzf ${BACKUPLATEST} -C / &> /dev/null ; then
        logger INFO "Successfully restored \"${1}\" last backup files."
      else
        logger ERROR "Can't restored \"${1}\" last backup files."
      fi
    else
      logger ERROR "Can't removed \"${1}\" files for the restore."
      exit 1
    fi
  else
    logger ERROR "Last backup \"${BACKUPLATEST}\" is not validated, script will exit now!"
    exit 1
  fi
}

function restoreDatabase() {
  if [ ${1} == "jira" ]; then
    APP_CONFIG=$(find ${PATH_DATA}/ -name dbconfig.xml)
    if [ ! "x${APP_CONFIG}" == "x" ] ; then
      logger DEBUG "Found application config \"${APP_CONFIG}\"."
      MYSQL_PASSWORD=$(grep password ${APP_CONFIG} | cut -d">" -f2 | cut -d"<" -f1)
    else
      logger ERROR "Can't find database configuration file for \"${1}\"."
      exit 1
    fi
  elif [ ${1} == "stash" ]; then
    APP_CONFIG=$(find ${PATH_DATA}/ -name stash-config.properties)
    if [ ! "x${APP_CONFIG}" == "x" ] ; then
      logger DEBUG "Found application config \"${APP_CONFIG}\"."
      MYSQL_PASSWORD=$(grep password ${APP_CONFIG} | cut -d"=" -f2)
    else
      logger ERROR "Can't grep database password for \"${1}\"."
      exit 1
    fi
  else
    APP_CONFIG=$(find ${PATH_DATA}/ -name ${1}.cfg.xml)
    if [ ! "x${APP_CONFIG}" == "x" ] ; then
      logger DEBUG "Found application config \"${APP_CONFIG}\"."
      MYSQL_PASSWORD=$(grep hibernate.connection.password ${APP_CONFIG} | cut -d">" -f2 | cut -d"<" -f1)
    else
      logger ERROR "Can't grep database credentials from \"${1}\" config."
    fi
  fi
  if [ ! "x${MYSQL_PASSWORD}" == "x" ] ; then
    if mysql -u${1} -p${MYSQL_PASSWORD} ${1} < ${PATH_DATA}/${1}_database_backup.sql ; then
      logger INFO "Successfully restore \"${1}\" dump \"${PATH_DATA}/${1}_database_backup.sql\"."
    else
      logger ERROR "Can't restore \"${1}\" dump \"${PATH_DATA}/${1}_database_backup.sql\"."
    fi
  else
    logger ERROR "Can't grep database credentials from \"${1}\" config."
  fi
  unset MYSQL_PASSWORD
}

#-----------------------------------------------------------------------------------------------------
# function calls
#-----------------------------------------------------------------------------------------------------
if [ ${JOB_SHOW} -eq 1 ] ; then
  for APP in ${APPS}; do
    showApp ${APP}
  done
fi

if [ ${JOB_INSTALL} -eq 1 ] ; then
  checkMemoryusage
  checkFilesystem
  deployLatestJava
  installTools
  getServerMemory
  installPostfix
  if [ ${EXT_PROXY} -ne 1 ] ; then
    installApache
    createCerts
  fi
  installMySQL
  for APP in ${APPS}; do
    PATH_DATA="${PATH_DEST}/${APP}/data"
    PATH_BACKUP="${PATH_DEST}/${APP}/backup"
    createDatabase ${APP}
    createFolders ${APP}
    createCredentials ${APP}
    setEnvirement ${APP}
    deployLatestBin ${APP}
    deployInitScript ${APP}
    deployDriverJDBC ${APP}
    configTomcatProxy ${APP}
    setHomes ${APP}
    serverMemorycalc ${APP}
    setFixes ${APP}
    startApp ${APP}
    createVhost ${APP}
    logger INFO "Successfully installed \"${APP}\"."
  done
  logger INFO "Successfully finished astack4atlassian.\n"
fi 

if [ ${JOB_UPDATE} -eq 1 ] ; then
  checkFilesystem
  deployLatestJava
  for APP in ${APPS}; do
    PATH_DATA="${PATH_DEST}/${APP}/data"
    PATH_BACKUP="${PATH_DEST}/${APP}/backup"
    stopApp ${APP}
  done
  getServerMemory
  for APP in ${APPS}; do
    deployLatestBin ${APP}
    deployDriverJDBC ${APP}
    configTomcatProxy ${APP}
    setHomes ${APP}
    serverMemorycalc ${APP}
    setFixes ${APP}
    startApp ${APP}
    logger INFO "Successfully updated \"${APP}\"."
  done
  logger INFO "Successfully finished astack4atlassian.\n"
fi

if [ ${JOB_BACKUP} -eq 1 ] ; then
  checkFilesystem
  for APP in ${APPS}; do
    PATH_DATA="${PATH_DEST}/${APP}/data"
    PATH_BACKUP="${PATH_DEST}/${APP}/backup"
    stopApp ${APP}
    backupDatabase ${APP}
    backupHome ${APP}
    startApp ${APP}
    logger INFO "Successfully backup \"${APP}\"."
  done
  logger INFO "Successfully finished astack4atlassian.\n"
fi

if [ ${JOB_RESTORE} -eq 1 ] ; then
  checkFilesystem
  for APP in ${APPS}; do
    PATH_DATA="${PATH_DEST}/${APP}/data"
    PATH_BACKUP="${PATH_DEST}/${APP}/backup"
    stopApp ${APP}
    restoreLatestData ${APP}
    restoreDatabase ${APP}
    startApp ${APP}
    logger INFO "Successfully restore \"${APP}\"."
  done
  logger INFO "Successfully finished astack4atlassian.\n"
fi

if [ ${JOB_PURGE} -eq 1 ] ; then
  read -r -p "Are you sure? [Y/n] " response
  if [[ $response =~ ^([yY][eE][sS]|[yY])$ ]]; then
    purgeJava
    for APP in ${APPS}; do
      stopApp ${APP}
      purgeCredentials ${APP}
      purgeFolders ${APP}
      purgeInitScript ${APP}
      if [ ${EXT_PROXY} -ne 1 ] ; then
        purgeVhost ${APP}
      fi
      logger INFO "Successfully purged \"${APP}\"."
    done
  fi
  logger INFO "Successfully finished astack4atlassian.\n"
fi

if [ ${JOB_TEST} -eq 1 ] ; then
    installTools
fi

unset MYSQL_PASS
unset APP_MEM_FREE
unset APP_MEM_PERM
unset APP_MEM_HEAP
unset APP_MEM_PERM

exit 0
